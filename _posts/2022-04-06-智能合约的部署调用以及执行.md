---
layout:     post   				   
title:      智能合约的部署调用以及执行				
subtitle:   smart contract 
date:       2022-04-06 				
author:     pzy 						
header-img: img/post-bg-desk1.jpeg 	
catalog: true 						
tags:							
    - 智能合约
---



> **关于以太坊智能合约是如何被部署与调用的，需要从交易说起：**

交易在以太坊官方实现（基于版本v1.10）中的结构体定义为

```go
// Transaction is an Ethereum transaction.
type Transaction struct {
	inner TxData    // Consensus contents of a transaction
	time  time.Time // Time first seen locally (spam avoidance)

	// caches
	hash atomic.Value
	size atomic.Value
	from atomic.Value
}

// NewTx creates a new transaction.
func NewTx(inner TxData) *Transaction {
	tx := new(Transaction)
	tx.setDecoded(inner.copy(), 0)
	return tx
}

// TxData is the underlying data of a transaction.
//
// This is implemented by DynamicFeeTx, LegacyTx and AccessListTx.
type TxData interface {
	txType() byte // returns the type ID
	copy() TxData // creates a deep copy and initializes all fields

	chainID() *big.Int
	accessList() AccessList
	data() []byte
	gas() uint64
	gasPrice() *big.Int
	gasTipCap() *big.Int
	gasFeeCap() *big.Int
	value() *big.Int
	nonce() uint64
	to() *common.Address

	rawSignatureValues() (v, r, s *big.Int)
	setSignatureValues(chainID, v, r, s *big.Int)
}
```

```go
type LegacyTx struct {
 Nonce    uint64          // nonce of sender account
 GasPrice *big.Int        // wei per gas
 Gas      uint64          // gas limit
 To       *common.Address `rlp:"nil"` // nil means contract creation
 Value    *big.Int        // wei amount
 Data     []byte          // contract invocation input data
 V, R, S  *big.Int        // signature values
}
```

注意，实际上在源码中是以接口的形式表示的，LegacyTx实际上是接口的一种实现，代表的是以太坊交易最初的定义

这里我们可以看见智能合约的相关信息是作为input data被放在交易当中的

> **以太坊智能合约的部署和调用都是以交易的形式来完成的**

---

## 合约部署的过程

1.用户用solidity编写智能合约，假设源码文件为contract.sol,经过编译器编译后变成字节码的形式

2.外部账户发起部署合约的交易，字节码作为input data随交易一起提交到区块链上

3.该交易会被节点验证是否合法，若合法则被放入交易池中等待矿工打包进区块，分发到节点

4.遍历区块中的交易，该智能合约在EVM虚拟机中执行，计算出智能合约部署的地址等运算结果

5.运算结果被打包到区块中，经过共识后新区块将被链接到主链

---

补充：关于区块

```go
//区块头结构体
// Header represents a block header in the Ethereum blockchain.
type Header struct {
	ParentHash  common.Hash    `json:"parentHash"       gencodec:"required"`
	UncleHash   common.Hash    `json:"sha3Uncles"       gencodec:"required"`
	Coinbase    common.Address `json:"miner"            gencodec:"required"`
	Root        common.Hash    `json:"stateRoot"        gencodec:"required"`
	TxHash      common.Hash    `json:"transactionsRoot" gencodec:"required"`
	ReceiptHash common.Hash    `json:"receiptsRoot"     gencodec:"required"`
	Bloom       Bloom          `json:"logsBloom"        gencodec:"required"`
	Difficulty  *big.Int       `json:"difficulty"       gencodec:"required"`
	Number      *big.Int       `json:"number"           gencodec:"required"`
	GasLimit    uint64         `json:"gasLimit"         gencodec:"required"`
	GasUsed     uint64         `json:"gasUsed"          gencodec:"required"`
	Time        uint64         `json:"timestamp"        gencodec:"required"`
	Extra       []byte         `json:"extraData"        gencodec:"required"`
	MixDigest   common.Hash    `json:"mixHash"`
	Nonce       BlockNonce     `json:"nonce"`
	// BaseFee was added by EIP-1559 and is ignored in legacy headers.
	BaseFee *big.Int `json:"baseFeePerGas" rlp:"optional"`
	/*
		TODO (MariusVanDerWijden) Add this field once needed
		// Random was added during the merge and contains the BeaconState randomness
		Random common.Hash `json:"random" rlp:"optional"`
	*/
}
```

```go
//区块体的结构，包含了交易列表和叔块列表
// Body is a simple (mutable, non-safe) data container for storing and moving
// a block's data contents (transactions and uncles) together.
type Body struct {
	Transactions []*Transaction
	Uncles       []*Header
}
```

---

## **合约被调用的过程**

1.交易（外部账户发起的对合约的调用）或消息（内部账户发起的合约之间的调用）被提交到区块链

2.这里和部署的交易不同，输入的数据既包含了from,to两个地址，也包含了要调用的函数名与参数

3.以太坊会使用 SHA-3 算法对函数计算函数摘要，具体表现为 4 个字节的函数 ID 形式

4.每一个参数的值都会是 32 字节的长度

举例：

```go
//比如要调用的函数为
transfer(address _to, uint256 _value)
//经过计算得到的函数ID为
0xa9059cbb
//两个参数为
[0]:000000000000000000000000e41d2489571d322189246dafa5ebde1f4699f498
[1]:00000000000000000000000000000000000000000000006c66eafbb939565c00
这一连串的十六进制字符会作为input和from地址，to地址一起放入调用合约的交易中

```

5.后面的过程和部署过程类似

补充：

智能合约间的消息调用（假设是合约a调用合约b）

以太坊提供 4 种进行消息调用的方式，分别是 call、callcode、delegatecall、staticcall

1.call 是使用消息调用最常用的方式，调用后产生的内部交易发送者变为合约 b 的地址，合约 b 的执行环境为合约b 的代码上下文

2.使用 callcode 的区别在于合约 b 的执行环境为合约 a 的代码上下文

3.delegatecall 称为委托调用，它与 call 的区别在于，调用后产生的内部交易发送者仍然是合约 a 的地址，且合约 b 的执行环境仍为合约 a 的代码上下文，使用delegatecall 可以实现在运行合约 a 时动态的加载合约 b 的代码来运行（因此，以太坊可以实现代码库的设计，将代码库放于一个合约中，需要调用这个代码库时直接使用 delegetecall 调用该合约即可）

4.使用 staticcall调用合约，将不允许合约读写状态变量

## **合约执行的环境-EVM**

一共有三种存储结构：分别是堆栈（stack）、内存（memory）、存储（ storage）

**堆栈**记录了EVM的操作指令的操作数和计算结果等，每个堆栈项的大小都是 256 位，最大
栈深为 1024 个堆栈项。

**内存**是一片连续的临时空间，可用于存储函数参数、函数返回值等，内存也是按 256 位的大小进行扩展。

**存储**位于每个账户中，是一块可永久性存储数据的空间，类似于数据库，以键值对的方式存储重要的状态信息（如账户的余额），键值对的大小也是 256 位。

每一个EVM指令都和合约的执行操作相关

这里举例以演示合约的执行过程：

1.调用方传入数据（如合约地址、交易输入数据等）给客户端

2.客户端到合约账户的存储中读取合约的EVM字节码

3.客户端初始化一个新的EVM虚拟机，智能合约的执行会从字节码序列的头部开始

4.交易的输入数据会被先解析，函数id和函数参数放入内存中，跳转到函数所在的代码块，开始进行函数调用

5.指令结束后改变pc指针的指示，EVM虚拟机将按照PC指针的找到下一个指令执行

6.执行完毕后客户端从内存中获取函数执行的返回值，并发送给调用方

>本文主要参考自：
>
>https://github.com/hsyodyssey/Understanding-Ethereum-Go-version/blob/main/CN/02_transaction.md
>
>Li ting,面向区块链智能合约的实时漏洞检测技术研究
>
